Lifted Symmetry Detection and
Breaking for MAP Inference

Tim Kopp

University of Rochester

Rochester, NY

Parag Singla
I.I.T. Delhi

Hauz Khas, New Delhi

Henry Kautz

University of Rochester

Rochester, NY

tkopp@cs.rochester.edu

parags@cse.iitd.ac.in

kautz@cs.rochester.edu

Abstract

Symmetry breaking is a technique for speeding up propositional satisﬁability test-
ing by adding constraints to the theory that restrict the search space while preserv-
ing satisﬁability. In this work, we extend symmetry breaking to the problem of
model ﬁnding in weighted and unweighted relational theories, a class of problems
that includes MAP inference in Markov Logic and similar statistical-relational
languages. We introduce term symmetries, which are induced by an evidence
set and extend to symmetries over a relational theory. We provide the important
special case of term equivalent symmetries, showing that such symmetries can
be found in low-degree polynomial time. We show how to break an exponential
number of these symmetries with added constraints whose number is linear in the
size of the domain. We demonstrate the effectiveness of these techniques through
experiments in two relational domains. We also discuss the connections between
relational symmetry breaking and work on lifted inference in statistical-relational
reasoning.

Introduction

1
Symmetry-breaking is an approach to speeding up satisﬁability testing by adding constraints, called
symmetry-breaking predicates (SBPs), to a theory [7, 1, 16]. Symmetries in the theory deﬁne a
partitioning over the space of truth assignments, where the assignments in a partition either all satisfy
or all fail to satisfy the theory. The added SBPs rule out some but not all of the truth assignments in
the partitions, thus reducing the size of the search space while preserving satisﬁability.
We extend the notion of symmetry-breaking to model-ﬁnding in relational theories. A relational
theory is speciﬁed by a set of ﬁrst-order axioms over ﬁnite domains, optional weights on the axioms
or predicates of the theory, and a set of ground literals representing evidence. By model ﬁnding
we mean satisﬁability testing (unweighted theories), weighted MaxSAT (weights on axioms), or
maximum weighted model ﬁnding (weights on predicates). The weighted versions of model ﬁnding
encompass MAP inference in Markov Logic and similar statistical-relational languages.
We introduce methods for ﬁnding symmetries in a relational theory that do not depend upon solving
graph isomorphism over its full propositional grounding. We show how graph isomorphism can be
applied to just the evidence portion of a relational theory in order to ﬁnd the set of what we call term
symmetries. We go on to deﬁne the important subclass of term equivalent symmetries, and show that
they can be found in O(nM log M ) time where n is the number of constants and M is the size of
the evidence.
Next we provide the formulation for breaking term and term equivalent symmetries. An inherent
problem in symmetry-breaking is that a propositional theory may have an exponential number of
symmetries, so breaking them individually would increase the size of the theory exponentially. This
is typically handled by breaking only a portion of the symmetries. We show that term equivalent
symmetries provide a compact representation of exponentially many symmetries, and an exponen-

1

tially large subset of these can be broken by a small (linear) number of SBPs. We demonstrate these
ideas on two relational domains and compare our approach to other methods for MAP inference in
Markov Logic.
2 Background
Symmetry Breaking for SAT Symmetry-breaking for satisﬁability testing, introduced by Craw-
ford et. al.[7], is based upon concepts from group theory. A permutation θ is a mapping from a set L
to itself. A permutation group is a set of permutations that is closed under composition and contains
the identity and a unique inverse for every element. A literal is an atom or its negation. A clause
is a disjunction over literals. A CNF theory T is a set (conjunction) of clauses. Let L be the set of
literals of T . We consider only permutations that respect negation, that is θ(¬l) = ¬θ(l) (l ∈ L).
The action of a permutation on a theory, written θ(T ), is the CNF formula created by applying θ to
each literal in T . We say θ is a symmetry of T if it results in the same theory i.e. θ(T ) = T .
A model M is a truth assignment to the atoms of a theory. The action of θ on M, written θ(M ),
is the model where θ(M )(P ) = M (θ(P )). The key property of θ being a symmetry of T is that
M |= T iff θ(M ) |= T . The orbit of a model M under a symmetry group Θ is the set of models
that can be obtained by applying any of the symmetries in Θ. A symmetry group divides the space
of models into disjoint sets, where the models in an orbit either all satisfy or all do not satisfy the
theory. The idea of symmetry-breaking is to add clauses to T rule out many of the models, but are
guaranteed to not rule out at least one model in each orbit. Note that symmetry-breaking preserves
satisﬁability of a theory.
Symmetries can be found in CNF theories using a reduction to graph isomorphism, a problem that is
thought to require super-polynomial time in the worst case, but which can often be efﬁciently solved
in practice [18]. The added clauses are called symmetry-breaking predicates (SBPs). If we place
a ﬁxed order on the atoms of theory, then a model can be associated with a binary number, where
the i-th digit, 0 or 1, speciﬁes the value of the i-th atom, false or true. Lex-leader SBPs rule out
models that are not the lexicographically-smallest members of their orbits. The formulation below
is equivalent to the lex-leader SBP given by Crawford et. al. in [7]:

(cid:94)

(cid:16) (cid:94)

SBP (θ) =

1≤i≤n

1≤j<i

(cid:17) ⇒ vi ⇒ θ(vi)

vj ⇔ θ(vj)

(1)

where vi is the ith variable in the ordering of n variables, and θ is a symmetry over variables.
Even though graph isomorphism is relatively fast in practice, a theory may have exponentially many
symmetries. Therefore, breaking all the symmetries is often impractical, though partial symmetry-
breaking is still useful. It is possible to devise new SBPs that can break exponentially more symme-
tries than the standard form described above; we do so in Section 5.2.
Relational Theories We deﬁne a relational theory as a tuple T = (F, W,E), where F is a set
of ﬁrst-order formulas, W a mapping of predicates and negated predicates to strictly positive real
numbers (weights), and E is a set of evidence. We restrict the formulas in F to be built from
predicates, variables, quantiﬁers, and logical connectives, but no constants or function symbols. E
is a set of ground literals; that is, literals built from predicates and constant symbols. The predicate
arguments and constant symbols are typed. Universal and existential quantiﬁcation is over the set of
the theory’s constants D (i.e. the constants that appear in its evidence). Any constants not appearing
explicitly in the evidence can be incorporated by introducing a unary predicate for each constant
type and adding the groundings for those constants to the evidence. Any formula containing a
constant can be made constant-free, by introducing a new unary predicate for each constant, and
then including that predicate applied to that constant in the evidence. A ground theory can be seen
as a special case of a relational theory where each predicate is argument free.
We deﬁne the weight of a positive ground literal P (C1, . . . , Ck) of a theory as W (P ), and the weight
of negative ground literal ¬P (C1, . . . , Ck) as W (¬P ). In other words, all positive groundings of a
literal have the same weight, as do all negative groundings. The weight of model M with respect
to a theory (F, W,E) is 0 if M fails to satisfy any part of F or E; otherwise, it is the product of the
weights of the ground atoms that are true in M. Maximum weighted model-ﬁnding is the task for
ﬁnding a model of maximum weight with respect to T . A relational theory can be taken to deﬁne a
probability distribution over the set of models, where the probability of model is proportional to its

2

weight. Maximum weighted model-ﬁnding thus computes MAP (most probable explanation) for a
given theory. Ordinary satisﬁability corresponds to the case where W simply sets the weights of all
literals to 1.
Languages such as Markov Logic [12] use an alternative representation and specify real-valued
weights on formulas rather than positive weights on predicates and their negations. The MAP prob-
lem can be formulated as the weighted-MaxSAT problem, i.e. ﬁnding a model maximizing the sum
of the weights of satisﬁed clauses. This can be translated to our notation by introducing a new pred-
icate for each original formula, whose arguments are the free variables in the original formula. F
asserts that the predicate is equivalent to the original formula, and W asserts that the weight of the
new predicate is e raised to the weight of the original formula. Solving weighted MaxSAT in the
alternate representation is thus identical to solving maximum weighted model-ﬁnding in the trans-
lated theory. For the rest of the discussion in this paper, we will assume that the theory is speciﬁed
with weights on predicates (and their negations).
3 Related Work
Our work has connections to research in both the machine learning and constraint-satisfaction re-
search communities. Most research in statistical-relational machine learning has concentrated on
modifying or creating novel probabilistic inference algorithms to exploit symmetries, as opposed to
symmetry-breaking’s solver-independent approach. Developments include lifted versions of vari-
able elimination [27, 8], message passing [29, 30, 23], and DPLL [14]. Our approach of deﬁning
symmetries using group theory and detecting them by graph isomorphism is shared by Bui et al.’s
work on lifted variational inference [5] and Apsel et al.’s work on cluster signatures [2]. Bui notes
that symmetry groups can be deﬁned on the basis of unobserved constants in the domain, while we
have developed methods to explicitly ﬁnd symmetries among constants that do appear in the evi-
dence. Niepert also gives a group-theoretic formalism of symmetries in relational theories [24, 25],
applying them to MCMC methods. Another line of work is to make use of problem transformations.
First-order knowledge compilation [10, 11] transforms a relational problem into a form for which
MAP and marginal inference is tractable. This is a much more extensive and computationally com-
plex transformation than symmetry-breaking. Mladenov et al. [22] propose an approach to translate
a linear program over a relational domain into an equivalent lifted linear program based on message
passing computations, which can then be solved using any off-the-shelf LP solver. Recent work
on MAP inference in Markov Logic has identiﬁed special cases where a relational formula can be
transformed by replacing a quantiﬁed formula with a single grounding of the formula [21].
Relatively little work in SRL has explicitly examined the role of evidence, separate from the ﬁrst-
order part of a theory, on symmetries. One exception is [31], which presents a heuristic method
for approximating an evidence set in order to increase the number of symmetries it induces. Bui et
al. [4] consider the case of a theory plus evidence pair, where the theory has symmetries that are
broken by the evidence. They show that if the evidence is soft and consists only of unary predicates,
then lifting based on the theory followed by incorporation of evidence enables polynomial time
inference. Extending the results of [4], Van Den Broeck and Darwiche [9] show that dealing with
binary evidence is NP-hard in general but can be done efﬁciently if there is a corresponding low
rank Boolean matrix factorization. They also propose approximation schemes based on this idea.
We brieﬂy touch upon the extensive literature that has grown around the use of symmetries in con-
straint satisfaction. Symmetry detection has been based either on graph isomorphism on proposi-
tional theories as in the original work by by Crawford et. al [7]; by interchangeability of row and/or
columns in CSPs speciﬁed in matrix form [20]; by checking for other special cases of geometric
symmetries [28], or by determining that domain elements for a variable are exchangeable [3]. (The
last is a special case of our term equivalent symmetries.) Researchers have suggested symmetry-
aware modiﬁcations to backtracking CSP solvers for variable selection, branch pruning, and no-
good learning [20, 13]. A recent survey of symmetry breaking for CSP [32] described alternatives
to the lex-leader formulation of SBPs, including one based on Gray codes.
4 Symmetries in Relational Theories
In this section, we will formally introduce the notion of symmetries over relational theories and
give efﬁcient algorithms to ﬁnd them. Symmetries of a relational theory can be deﬁned in terms of
symmetries over the corresponding ground theory.

3

Deﬁnition 4.1. Let T denote a relational theory. Let the T G denote the theory obtained by grounding
the formulas in T . Let L denote the set of (ground) literals in T G. We say that a permutation θ of
the set L is a symmetry of the relational theory T if θ maps the ground theory T G back to itself
i.e. θ(T G) = T G. We denote the action of θ on the original theory as θ(T ) = T .
A straightforward way to ﬁnd symmetries over a relational theory T is to ﬁrst map it to correspond-
ing ground theory T G and then ﬁnd symmetries over it using reduction to graph isomorphism. The
complexity of ﬁnding symmetries in this way is the same as that of graph isomorphism, which is
believed to be worst-case super-polynomial. Further, the number of symmetries found is potentially
exponential in the number of ground literals. This is particularly signiﬁcant for relational theories
since the number of ground literals itself is exponential in the highest predicate arity. Computing
symmetries at the ground level can therefore be prohibitively expensive for theories with high pred-
icate arity and many constants. In our work below, we exploit the underlying template structure of
the relational theory to directly generate symmetries based on the evidence.

4.1 Term Symmetries
We introduce the notion of symmetries deﬁned over terms (constants) appearing in a theory T , called
term symmetries.
Deﬁnition 4.2. Let T be a relational theory. Let D be the set of constants appearing in the theory.
Then, a permutation θ over the term set D is said to be a term symmetry with respect to evidence E
if application of θ on the terms appearing in E, denoted by θ(E), maps E back to itself. We will also
refer to θ as an evidence symmetry for the set E.
The problem of ﬁnding term symmetries can be reduced to colored graph isomorphism. We con-
struct a graph G as follows: for each predicate P and it’s negation, G has a node and a unique color
is assigned to every such node. G also has a unique color for each type in the domain. There is a
node for every term which takes the color of its type. We call an ordered list of terms an argument
list, e.g., given the literal P (C1, C2), where C1, C2 ∈ D, the argument list is (C1, C2). The type of
an argument list is simply the cross-product of the types of the terms appearing in it. G has a node
for every argument list appearing in the evidence, which takes the color of its type.
For every evidence literal, there is an edge between the predicate node (or its negation) and the
corresponding argument list node. There is also an edge between the argument list node and each of
the terms appearing in the list. Thus, for the previous example, an edge will be placed between the
node for P and the node for (C1, C2), as well as an edge each between (C1, C2) and the nodes for
C1 and C2.
Any automorphism of G will map (negated) predicate nodes to themselves and terms will be mapped
in a manner that their association with the corresponding predicate node in the evidence is preserved.
Hence, automorphisms of G will correspond to term symmetries in evidence E. Next, we will
establish a relationship between permutation of terms in the evidence to the permutations of literals
in the ground theory.
Deﬁnition 4.3. Let T be a relational theory. Let E be the evidence set and let D be the set of
terms appearing in E. Given a permutation θ of the terms in the set D, we associate a corre-
sponding permutation θT over the ground literals of the form P (C1, C2, . . . , Ck) in T , such that
θT (P (C1, C2, . . . , Ck)) = P (θ(C1), θ(C2), . . . , θ(Ck)) (and similarly for negated literals).
We can now associate a symmetry θ over the terms with a symmetry of the theory T . The following
lemma is proven in the supplementary material:
Lemma 4.1. Let T be a relational theory. Let E denote the evidence set. Let D be the set of terms
appearing in E. If θ is term symmetry for the evidence E, then, the associated theory permutation
θT is also a symmetry of T .
In order to ﬁnd the term symmetries, we can resort to solving a graph isomorphism problem of
size O(|E|), where |E| is the number of literals in the evidence. Directly ﬁnding symmetries over the
ground literals requires solving a problem of size O(|D|k), |D| being the set of constants and k being
the highest predicate arity. In the worst case where everything is fully observed, |E| = O(|D|k), but
in practice it is much smaller. Next, we present an important subclass of term symmetries, called
term equivalent symmetries, which capture a wide subset of all the symmetries present in the theory,
and can be efﬁciently detected and broken.

4

4.2 Term Equivalent Symmetries
A term equivalent symmetry is a set of term symmetries that divides the set of terms into equivalence
classes such that any permutation which maps terms within the same equivalence class is a symmetry
of the evidence set. Let Z = {Z1, Z2, . . . , Zm} denote a partition of the term set D into m disjoint
subsets. Given a partition Z, we say that two terms are term equivalent (with respect to Z) if they
occur in the same component of Z. We deﬁne a partition preserving permutation as follows.
Deﬁnition 4.4. Given a set of terms D and its disjoint partition Z, we say that a permutation θ of the
terms in D is a partition preserving permutation of D with respect to the partition Z if ∀Cj, Ck ∈
D, θ(Cj) = Ck implies that ∃ Zi ∈ Z st Cj, Ck ∈ Zi. In other words, θ is partition preserving if it
permutes terms within the same component of Z.
The set of all partition preserving permutations (with respect to a partition Z) forms a group. We
will denote this group by ΘZ. It is easy to see that ΘZ divides the set of terms in equivalence classes.
Next, we deﬁne the notion of term equivalent symmetries.
Deﬁnition 4.5. Let T be a relational theory and E denote the evidence set. Let D be the set of terms
in E and Z be a disjoint partition of terms in D. Then, given the partition preserving permutation
ΘZ, we say that ΘZ is a term equivalent symmetry group of D, if ∀θ ∈ ΘZ, θ is a symmetry of E.
We will refer to each symmetry θ ∈ ΘZ as a term equivalent symmetry of E.
A partition Z of term set D is a term equivalent partition if the partition preserving group ΘZ is
a symmetry group of D. We refer to each partition element Zi as a term equivalent subset. The
term equivalent symmetry group can be thought of as a set of symmetry subgroups ΘZi’s, one for
each term subset Zi, such that, Zi allows for all possible permutations of terms within the set Zi
and deﬁnes an identity mapping for terms in other subsets. Note that the size of term equivalent
i=1|Zi|!. Despite its large size, it can be very efﬁciently represented
symmetry group is given by Πm
by simply storing the partition Z over the term set D. Note that this formulation works equally well
for typed as well untyped theories; in a typed theory no two terms of differing types can appear in the
same subset. Next, we will look at an efﬁcient algorithm for ﬁnding a partition Z which corresponds
to a term equivalent symmetry group over D.
Let the evidence be given by E = {l1, l2, . . . , lk}, where each li is a ground literal. Intuitively,
two terms are term equivalent if they occur in exactly the same context in the evidence. For
example, if evidence for constant A is {P1(A, X), P2(A, Y, A)}, then the context for term A is
P1(∗, X), P2(∗, Y,∗). Note that here the positions where A occurred in the evidence has been
marked by a ∗. Any other term sharing the same context would be term equivalent to A. To ﬁnd
the set of all the equivalent terms, we ﬁrst compute the context for each term. Then, we sort each
context based on some lexicographic order deﬁned over predicate symbols and term symbols. Once
the context has been sorted, we can simply hash the context for each term and put those which have
the same context in the same equivalence class. If the evidence size is given by |E| = M and number
of terms in evidence is n, then, the above procedure will take O(nM log(M )) time. The M log(M )
factor is for sorting the context for a single term. Hashing the sorted term takes constant time. This
is done for each term, hence the factor of n. See the supplement for more details and an example.
5 Breaking Symmetries Over Terms
In this section, we provide the SBP formulation for term as well as term equivalent symmetries.
5.1 Breaking Term Symmetries
Consider a relational theory T that has term symmetries {θ1, . . . , θk}. Fix an ordering P1, . . . , Pr
over the predicates, an ordering over the predicate positions, and an ordering C1, . . . , C|D| over the
terms. If T is typed, ﬁx an ordering over types and an ordering over the terms within each type.
This induces a straightforward ordering over the ground atoms of the theory G1, . . . , Gn.
Let θ be a term symmetry. Consider the following SBP (based on Equation 1) to break θ:

(cid:17) ⇒ Gi ⇒ θ(Gi)

Gj ⇔ θ(Gj)

(cid:94)

(cid:16) (cid:94)

SBP (θ) =

1≤i≤n

1≤j<i

Theorem 5.1. If T is weighted, the max model for T ∧ SBP (θ) is a max model for T , and it has
the same weight in both theories.

5

The proof of this theorem follows from [7]. Essentially, an ordering is placed on the atoms of the
theory, which induces an ordering on the models. The SBP constraints ensure that if a set of models
are in the same orbit, i.e. symmetric under θ, then only the ﬁrst of those models in the ordering is
admitted.
5.2 Breaking Term Equivalent Symmetries
Let Z = {Z1, . . . , Z|Z|} be the term equivalent partitioning over the terms. Let θi
j,k be the term
symmetry that swaps Cj and Ck, the jth and kth constants in an ordering over the term equivalent
subset Zi, and maps everything else to identity. We next show how to break exponentially many
symmetries that respect the term equivalent partition Z, using a linear-sized SBP. Consider the
following SBP (CSBP stands for Composite SBP):

|Z|(cid:94)

|Zi|−1(cid:94)

CSBP (Z) =

SBP (θi

j,j+1)

i=1

j=1
For each term (equivalent) symmetry of the form θi
j,j+1, we apply the SBP formulation from Sec-
tion 5.1 to break it. The formulation is cleverly choosing which symmetries to explicitly break, so
that exponentially many symmetries are broken. The inner conjunction iterates over all of the terms
in a term equivalent class. An ordering is placed on the terms, and the only symmetries that are
explicitly broken are those that swap two adjacent terms and map everything else to identity. All
of the adjacent pairs of terms in the ordering are broken in this way, with a linear number of calls
to SBP. As we show below, this excludes Ω(2|Zi|) models from the search space, while preserving
at least one model in each orbit. The outer conjunction iterates over the different term equivalent
subsets, breaking each one of them in turn. The following theorem states this in formal terms (see
the supplement for a proof):

Theorem 5.2. CSBP (Z) removes Ω((cid:80)|Z|

i=1 2|Zi|) models from the search space while preserving
at least one model in each orbit induced by the term equivalent symmetry group ΘZ.
Corollary 5.1. If T is weighted, the max model for T ∧ CSBP (Z) is a max model for T , and it
has the same weight in both theories.
6 Experiments
We pitted our term and term equivalent SBP formulations against other inference systems to demon-
strate their efﬁcacy. For each domain we tested on, we compared the following algorithms:
(1) Vanilla: running an exact MaxSAT solver on the grounded instance (2) Shatter: running an
exact MaxSAT solver on the grounded instance with SBPs added by the Shatter tool [1], (3) Term:
running an exact MaxSAT solver on the grounded instance with SBPs added by our term symmetry
detection algorithm, (4) Tequiv: running an exact MaxSAT solver on the grounded instance with
SBPs added by our term equivalent symmetry detection algorithm (5) RockIt: running RockIt [26]
on the MLN, (6) PTP: running the PTP algorithm [14] for marginal inference 1 on the MLN and
(7) MWS: running the approximate MaxWalkSAT algorithm used by Alchemy-22 on the grounded
instance. These algorithms were chosen so that our methods would be compared against a variety of
other techniques: ground techniques including regular MaxSAT (Vanilla), propositional symmetry-
breaking (Shatter), local search (MWS), and lifted techniques including cutting planes (RockIt) and
lifted rules (PTP). It should be noted that all the algorithms except MWS and RockIt are exact.
RockIt solves an LP relaxation but it always gave us an exact solution (whenever it could run).
Therefore, we report the solution quality only for MWS. All the experiments were run on a system
with a 2.2GHz Xeon processor and 62GB of memory.
The algorithms for Term and Tequiv were implemented as a pre-processing step before running a
MaxSAT solver. The MWS runs were allowed a varying number of ﬂips and up to ﬁve restarts.
For MWS, the reported results are with equal probability (0.5) of making a random or a greedy
move; other settings were tried, and the results were similar. Both PTP and RockIt were run using
the default setting of their parameters. We experimented on two relational domains: the classic
pigeonhole problem (PHP) with two different variants, and an Advisor domain (details below).

1The publicly available implementation of PTP only supports marginal inference. Though marginal infer-

ence is somewhat harder problem than MAP, PTP failed to run even on the smallest of instances.

2https://code.google.com/p/alchemy-2/

6

For ground instances that required an exact MaxSAT solver, we experimented with three different
solvers: MiniMaxSAT [15], Open-WBO [19], and Sat4j [17]. This was done because different
solvers and heuristics tend to work better on different application domains. We found that for PHP
(variant 1) Sat4j worked best, for PHP (variant 2) Open-WBO was the best and for Advisor Mini-
MaxSAT worked the best. We used the best MaxSAT solver for each domain.
PHP: In the PHP problem, we are given n pigeons and n−1 holes. The goal is to ﬁt each pigeon in a
unique hole (the problem is unsatisﬁable). We tried two variants of this problem. In the ﬁrst variant,
there are hard constraints that ensure that every hole has at most one pigeon and every pigeon is
in at most one hole. There is a soft constraint that states that every pigeon is in every hole. The
goal is to ﬁnd a max-model of the problem. The comparison with various algorithms is given in
Table 1a. Vanilla times out except for the smallest instance. PTP times out on all instances. Our
algorithms consistently outperform RockIt but are not able to outperform shatter (except for smaller
instances where they are marginally better). MWS was run on the largest instance (n=60) and results
are shown in Table 1d. MWS is unable to ﬁnd the optimal solution after 10 million ﬂips.
In the second PHP variant, there are hard constraints that ensure that every pigeon is in precisely one
hole. There is a soft constraint that each hole has at most one pigeon. The comparison with various
algorithms is given in in Table 1b. Vanilla times out except for the two smallest instances, and PTP
times out for all the instances. Our systems consistently outperform RockIt, and outperform shatter
for the larger instances. Tequiv outperforms Term because the detection step is much faster. MWS
(Table 1d) is able to ﬁnd the optimal within 100,000 ﬂips and is signiﬁcantly faster than all other
algorithms. Though MWS does better on this variant of PHP, it fails badly on the ﬁrst one. Further,
there is no way for MWS to know if it has reached the optimal unlike our (exact) approaches.
Advisor Domain: The advisor-advisee domain has three types: student, prof, and a research area.
There are predicates to indicate student/prof interest in an area and an advisor relationship between
students and profs. The theory has hard constraints that ensure that a) each student has precisely one
advisor b) students and their advisors share an interest. It also has a small negatively-weighted (soft)
constraint saying that a prof advises two different students. The interests of all students and profs
are fully observed. Students have one interest, profs have one or more (chosen randomly). There
is at least one prof interested in each area. The results for this domain are given in Table 1c gives
the comparisons. Vanilla is able to run only on the two smallest instances. PTP times out on every
instance as before. Our algorithms outpeform shatter but is outperformed by RockIt. MWS was run
on the two larger sized instances (see Table 1c) and it is able to outperform our system.
In order to make sure that poor performance of PTP is not due to evidence, we modiﬁed the PHP
formulation to work with a no evidence formulation. This did not help PTP either. Based on these
results, there is no clear winner among the algorithms which performs the best on all of these do-
mains. Among all the algorithms, Term, Tequiv and Shatter are the only ones which could run to
completion on all the instances that we tried. Among these, our algorithms won on PHP variant
2 (large instances) and the Advisor domain. Tequiv outperformed Term on PHP variant 2 (large
instances), and they performed similarly in the Advisor domain.
In the PHP variants, all of the pigeons are in one term equivalent symmetry group, and all of the
holes are in another. The PHP is of special interest, because pigeonhole structure was shown to be
present in hard random SAT formulas with very high probability [6]. In the advisor domain, there
is a term equivalent symmetry group of students for each area, and term equivalent symmetry group
of professors for each set of areas.
7 Conclusion and Future Work
In this work, we have provided the theoretical foundation for using symmetry-breaking techniques
from satisﬁability testing for MAP inference in weighted relational theories. We have presented the
class of term symmetries, and a subclass of term equivalent symmetries, both of which are found in
the evidence given with the theory. We have presented ways to detect and break both these classes.
For the class of term equivalent symmetries, the detection method runs in low-polynomial time, and
the number of SBPs required to break the symmetries is linear in the domain size. the algorithms
presented, and compared them against other systems on a set of relational domains. Future work
includes carefully characterizing the cases where our algorithms perform better than other systems,
experimenting on additional real-world domains, comparing with more lifted inference approaches,
and the application of similar techniques to the problem of marginal inference.

7

Table 1: Experiments with Lifted Symmetries for MAP Inference

#Pigeon Vanilla
0.246

(a) Soft Pigeon Hole Domain — Variant 1
Term

Shatter

Tequiv

0.01 + 0.39
TO 0.02 + 0.88
TO 0.08 + 1.85
TO 0.22 + 3.1
TO
1.6 + 12.7
TO
TO

7 + 72
54 + 889

0.01 + 0.24
0.04 + 0.74
0.13 + 1.37
0.36 + 3.9
1.4 + 20
4.06 + 93.3
18 + 1128

0.03 + 0.26
0.09 + 0.68
0.21 + 1.27
0.51 + 3.7
2.2 + 14
6.30 + 88.3
28 + 1128

RockIt
1.15
1.47
2.46
2.70
3.88
F
F

PTP
TO
TO
TO
TO
TO
TO
TO

5
10
15
20
30
40
60

(b) Soft Pigeon Hole Domain — Variant 2

#Pigeon Vanilla
0.002
37.44
TO
TO
TO
TO

5
10
15
40
80
125

Shatter

0.003 + 0.001
0.01 + 0.006
0.06 + 0.01
3.7 + 0.59
115 + 8.36
1090 + 20.98

Tequiv

1.28 + 0.002
1.19 + 0.004
1.29 + 0.01
4.9 + 0.17
50 + 1.7
269 + 10

Term

0.04 + 0.001
0.07 + 0.005
0.19 + 0.01
6.2 + 0.21
86 + 2.9
486 + 18

RockIt

1.1
6.6
TO
F
F
F

PTP
TO
TO
TO
TO
TO
TO

(c) Advisor Domain
Shatter

Tequiv

#Prof–#Student–#Area Vanilla
0.01 + 0.10
2.3
168
0.01 + 0.17
TO 0.02 + 0.90
TO 0.03 + 105
TO 0.07 + 62

4–12–2
4–16–2
6–18–3
6–24–3
8–24–4

0.02 + 0.01
0.03 + 0.05
0.05 + 0.84
0.07 + 45
0.10 + 56

Term

0.11 + 0.01
0.08 + 0.04
0.09 + 0.80
0.15 + 47
0.16 + 55

RockIt
1.25
2.06
6.56
1.47
13.4

PTP
TO
TO
TO
TO
TO

(d) MaxWalkSAT Results

Problem

Size

Optimal

pigeon1
pigeon2
advisor
advisor

60
125

6–18–3
8–24–4

3481

1

2094
3552

100,000

best
3496

1

2094
3552

time
4.4
3.8
0.4
0.5

1,000,000
time
best
39
3494
—
—
—
—
—
—

10,000,000
time
best
383
3491
—
—
—
—
—
—

All times are given in seconds. “TO” indicates the program timed out (30min). “F” indicates the program failed
without timeout (instance too large). The vanilla column is the time to ﬁnd the max model of the ground theory.
The ﬁrst three subtables give results for exact algorithms. The Shatter, Term, and Tequiv columns are the
same with propositional, term and term equivalent symmetries broken, respectively. These columns are given
as x + y, where x is the time to detect and break the symmetries, and y is the time to ﬁnd the max model.
The RockIt column is the time it takes RockIt to ﬁnd the max model. The lifted PTP algorithm was run on
every instance, and timed out on each instance. The last table gives the results for the approximate algorithm
MaxWalkSAT, giving the time it takes to perform a certain number of iterations, as well as the comparison
between the best model found on that run and the optimal model.

References
[1] Fadi A. Aloul, Igor L. Markov, and Karem A. Sakallah. Shatter: efﬁcient symmetry-breaking for boolean

satisﬁability. In Proc. of DAC, pages 836–839, 2003.

[2] Udi Apsel, Kristian Kersting, and Martin Mladenov. Lifting relational MAP-LPs using cluster signatures.

In Proc. of AAAI, pages 2403–2409, 2014.

[3] Gilles Audemard, Belaid Benhamou, and Laurent Henocque. Predicting and detecting symmetries in FOL

ﬁnite model search. J. Automated Reasoning, 36(3):177–212, 2006.

[4] Hung B. Bui, Tuyen N. Huynh, and Rodrigo de Salvo Braz. Exact lifted inference with distinct soft

evidence on every object. In Proc. of AAAI, 2012.

8

[5] Hung Hai Bui, Tuyen N. Huynh, and Sebastian Riedel. Automorphism groups of graphical models and

lifted variational inference. In Proc. of UAI, pages 132–141, 2013.

[6] Vasek Chv´atal and Endre Szemer´edi. Many hard examples for resolution. J. ACM, 35(4):759–768, 1988.
[7] James Crawford, Matthew Ginsberg, Eugene Luks, and Amitabha Roy. Symmetry-breaking predicates

for search problems. In Proc. of KR, pages 148–159, 1996.

[8] Rodrigo de Salvo Braz, Eyal Amir, and Dan Roth. Lifted ﬁrst-order probabilistic inference. In Proc. of

IJCAI, pages 1319–1325, 2005.

[9] Guy Van den Broeck and Adnan Darwiche. On the complexity and approximation of binary evidence in

lifted inference. In Proc. of NIPS, pages 2868–2876, 2013.

[10] Guy Van den Broeck and Jesse Davis. Conditioning in ﬁrst-order knowledge compilation and lifted

probabilistic inference. In Proc. of AAAI, 2012.

[11] Guy Van den Broeck, Nima Taghipour, Wannes Meert, Jesse Davis, and Luc De Raedt. Lifted probabilistic

inference by ﬁrst-order knowledge compilation. In Proc. of IJCAI, pages 2178–2185, 2011.

[12] Pedro Domingos and Daniel Lowd. Markov Logic: An Interface Layer for Artiﬁcial Intelligence. Synthe-

sis Lectures on Artiﬁcial Intelligence and Machine Learning. Morgan & Claypool Publishers, 2009.

[13] Pierre Flener, Justin Pearson, Meinolf Sellmann, Pascal Van Hentenryck, and Magnus Agren. Dynamic

structural symmetry breaking for constraint satisfaction problems. Constraints, 14(4):506–538, 2009.

[14] Vibhav Gogate and Pedro M. Domingos. Probabilistic theorem proving. In Proc. of UAI, pages 256–265,

2011.

[15] Federico Heras, Javier Larrosa, and Albert Oliveras. MiniMaxSAT: An Efﬁcient Weighted Max-SAT

solver. J. Artiﬁcial Intelligence Research, 31:1–32, 2008.

[16] Hadi Katebi, Karem A. Sakallah, and Igor L. Markov. Symmetry and satisﬁability: An update. In Theory

and Applications of Satisﬁability Testing, volume 6175, pages 113–127, 2010.

[17] Daniel Le Berre and Anne Parrain. The Sat4j library, release 2.2. JSAT, 7:59–64, 2010.
[18] E. M. Luks. Isomorphism of graphs of bounded valence can be tested in polynomial time. J. of Computer

System Science, 25:42–65, 1982.

[19] Ruben Martins, Vasco Manquinho, and Inˆes Lynce. Open-WBO: A modular maxsat solver,. In Theory

and Applications of Satisﬁability Testing, volume 8561 of Lecture Notes in Computer Science. 2014.

[20] Pedro Meseguer and Carme Torras. Exploiting symmetries within constraint satisfaction search. Artiﬁcial

Intelligence, 129(1-2):133–163, 2001.

[21] Happy Mittal, Prasoon Goyal, Vibhav G. Gogate, and Parag Singla. New rules for domain independent

lifted MAP inference. In Proc. of NIPS, pages 649–657, 2014.

[22] Martin Mladenov, Babak Ahmadi, and Kristian Kersting. Lifted linear programming. In Proc, of AISTATS,

pages 788–797, 2012.

[23] Martin Mladenov, Amir Globerson, and Kristian Kersting. Lifted message passing as reparametrization

of graphical models. In Proc. of UAI, pages 603–612, 2014.

[24] Mathias Niepert. Markov chains on orbits of permutation groups. In Proc, of UAI, pages 624–633, 2012.
[25] Mathias Niepert. Symmetry-aware marginal density estimation. In Proc. of AAAI, 2013.
[26] Jan Noessner, Mathias Niepert, and Heiner Stuckenschmidt. Rockit: Exploiting parallelism and symmetry

for MAP inference in statistical relational models. In Proc. of AAAI, 2013.

[27] David Poole. First-order probabilistic inference. In Proc. of IJCAI, pages 985–991, 2003.
[28] Meinolf Sellmann and Pascal Van Hentenryck. Structural symmetry breaking. In Proc. of IJCAI, pages

298–303, 2005.

[29] Parag Singla and Pedro Domingos. Lifted ﬁrst-order belief propagation. In Proc. of AAAI, pages 1094–

1099, 2008.

[30] Parag Singla, Aniruddh Nath, and Pedro M. Domingos. Approximate lifting techniques for belief propa-

gation. In Proc. of AAAI, pages 2497–2504, 2014.

[31] Deepak Venugopal and Vibhav Gogate. Evidence-based clustering for scalable inference in Markov logic.

In Proc. of ECML/PKDD, pages 258–273, 2014.

[32] Toby Walsh. Symmetry breaking constraints: Recent results. In Proc. of AAAI, 2012.

9

